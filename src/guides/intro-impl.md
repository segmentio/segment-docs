---
title: Segment for Developers
---

This guide explains all you need to know to get started with your Segment implementation, and directs you to more resources depending on your specific needs.

## What does Segment do?

In its simplest form, Segment sends messages about activities in your mobile apps, websites or servers, receives messages those messages, and translates and forwards the message contents to Destination tools. It also can send the contents of those messages to a bulk storage destination for archiving. In more complicated implementations, Segment can serve as a wrapper to trigger messages directly to other APIs, and can inspect, correct, classify and block the message contents.

## Types of Segment messages

Segment's libraries generate and send messages to our tracking API in JSON format, and provide a standard structure for the basic API calls. We also provide recommended JSON structure (also known as a schema, or 'Spec') that helps keep the most important parts of your data consistent, while allowing great flexibility in what other information you collect and where.

There are six calls in the basic tracking API, which answer specific questions:

- [Identify](/docs/spec/identify/): Who is the user?
- [Track](/docs/spec/track/): What are they doing?
- [Page](/docs/spec/page/): What web page are they on?
- [Screen](/docs/spec/screen/): What app screen are they on?
- [Group](/docs/spec/group/): What account or organization are they part of?
- [Alias](/docs/spec/alias/): What was their past identity?

Among these calls, you can think of Identify, Group, and Alias as similar types of calls, all to do with updating our understanding of the user who is triggering Segment messages. You can think of these calls as adding information to, or updating an object record in a database. Objects are described using "traits", which can collect as part of your calls.

The other three, Track, Page, and Screen, can be considered as increasingly specific types of events. Events can occur multiple times, but generate separate records which appended to a list, instead of being updated over time.

A Track call is the most basic type of call, and can represent any type of event. Page and Screen are similar and are triggered by a user viewing a page or screen, however Page calls can come from both web and mobile-web views, while Screen calls *only* occur on mobile devices. Because of the difference in platform, the context information collected is different between the two platforms.

## Anatomy of a Segment message

The most basic Segment message requires only a userID or anonymousID; all other fields are optional to allow for maximum flexibility. However, a normal Segment message has three main parts: the [common fields](/docs/spec/common/), the ["context" object](/docs/spec/common#context), and the properties (if it's an event) or traits (if it's an object).

The common fields include information specific to how the specific call was generated, like the timestamp and library name and version. The fields in the context object are usually generated by the library, and include information about the environment in which the call was generated: page path, user agent, OS, locale settings, etc. The properties and traits are optional and are where you customize the information you want to collect for your implementation.

Another common part of a Segment message is the integrations object, which you can use to explicitly filter which destinations the call is forwarded to. However this object is optional, and is often omitted in favor of non-code filtering options.

## Message schemas, Blocks, and Specs

The Segment "Specs" provide recommended message schemas - the information we recommend that you collect - for each type of call. These are recommendations not requirements, but if you follow these schema guidelines the Segment servers can more easily identify parts of your messages, and translate them to downstream tools.

In addition to the recommended message schemas, Segment also provides "blocks": recommendations on what information to collect and how to format it, for different industries and use cases. These are recommendations only, but by collecting all of the information in these blocks, you can ensure that common tools used in that use case have the information they need to function.

A third section of the Spec is the "industry specs" which provide recommendations that include an explicit translation or mapping in the Segment servers, to best power the downstream Destinations commonly used in these industries.



---
TODO MARK
---


two ways to implement
device mode
cloud mode

when to use which, considerations

How to start:
if starting fresh: take an inventory of tools you want to use, think about what questions you want to answer with your data

if implementing for parity: take inventory of tools already in use, their owners and the questions they answer. For each destination check which modes it supports, check which have cloud-sources, decide if and how you want to store your data for later analysis.

either way, start a tracking plan: write down the questions you want to answer with the data, and the data you want to track to answer it. can be simple, or can serve as the combination data dictionary and ownership directory for your organization
if you're a large organization, have many business units, or use external contractors who work on your site or app, you might want Protocols (todo expand why)

initialize a source:
in the segment app:
then implement: add snippet, import code, add library, w/e. add code calls to generate the messages on specific actions - maybe a button click, zooming in or out, or just loading a page
then hook up to destinations in the app

how do I test if it's working?
debugger, event tester/event delivery

troubleshooting: error codes

how do i stop specific data going to different destinations?
filtering
