---
title: Analytics for Node.js
sourceTitle: 'Node.js'
sourceCategory: 'Server'
shortName: 'node'
---


Our Node.js library lets you record analytics data from your node code. The requests hit our servers, and then we route your data to any analytics service you enable on your destinations page.

This library is open-source, so you can [check it out on Github](https://github.com/segmentio/analytics-node).

All of our server-side libraries are built for high-performance, so you can use them in your web server controller code. This library uses an internal queue to make `identify` and `track` calls non-blocking and fast. It also batches messages and flushes asynchronously to our servers.

Want to stay updated on releases? Subscribe to the [release feed](https://github.com/segmentio/analytics-node/releases.atom).

## Getting Started

### Install the Module

Run:

```
npm install --save analytics-node
```

This will add our Node library module to your `package.json`. The module exposes an `Analytics` constructor, which you need to initialize with your Segment source's **Write Key**, like so:

```javascript
var Analytics = require('analytics-node');
var analytics = new Analytics('YOUR_WRITE_KEY');
```

Of course, you'll want to replace `YOUR_WRITE_KEY` with your actual **Write Key** which you can find in Segment under your source settings.

This will create an instance of `Analytics` that you can use to send data to Segment for your project. The default initialization settings are production-ready and queue 20 messages before sending any requests. In development you might want to use [development settings](/docs/sources/server/node/#development).

## Identify

`identify` lets you tie a user to their actions and record traits about them.  It includes a unique User ID and any optional traits you know about them.

We recommend calling `identify` a single time when the user's account is first created, and only identifying again later when their traits change.

Example `identify` call:

```javascript
analytics.identify({
  userId: '019mr8mf4r',
  traits: {
    name: 'Michael Bolton',
    email: 'mbolton@initech.com',
    plan: 'Enterprise',
    friends: 42
  }
});
```
This call is identifying Michael by his unique User ID (the one you know him by in your database) and labeling him with `name`, `email`, `plan` and `friends` traits.

The `identify` call has the following fields:

<table class="api-table">
  <tr>
    <td>`userId` _String</td>
    <td>The ID for this user in your database.</td>
  </tr>
  <tr>
    <td>`traits` _Object, optional_</td>
    <td>A dictionary of [traits](/docs/spec/identify#traits) you know about the user. Things like: `email`, `name` or `friends`.</td>
  </tr>
  <tr>
    <td>`timestamp` _Date, optional_</td>
    <td>A Javascript date object representing when the identify took place. If the identify just happened, leave it out and we'll use the server's time. If you're importing data from the past make sure you to send a `timestamp`.</td>
  </tr>
  <tr>
    <td>`context` _Object, optional_</td>
    <td>A dictionary of extra [context](https://segment.com/docs/spec/common/#context) to attach to the call. _Note: `context` differs from `traits` because it is not attributes of the user itself._</td>
  </tr>
  <tr>
    <td>`anonymousId` _String, optional_</td>
    <td>An ID to associated with the user when you don't know who they are (eg., [the anonymousId generated by `analytics.js`](/docs/sources/website/analytics.js/#anonymous-id))</td>
  </tr>
</table>

Find details on the **identify method payload** in our [Spec](/docs/spec/identify/).

## Track

`track` lets you record the actions your users perform. Every action triggers what we call an "event", which can also have associated properties.

You'll want to track events that are indicators of success for your site, like **Signed Up**, **Item Purchased** or **Article Bookmarked**.

To get started, we recommend tracking just a few important events. You can always add more later!

Example `track` call:

```javascript
analytics.track({
  userId: '019mr8mf4r',
  event: 'Item Purchased',
  properties: {
    revenue: 39.95,
    shippingMethod: '2-day'
  }
});
```

This example `track` call tells us that your user just triggered the **Item Purchased** event with a revenue of $39.95 and chose your hypothetical '2-day' shipping.

`track` event properties can be anything you want to record. In this case, revenue and shipping method.

The `track` call has the following fields:

<table>
  <tr>
    <td>`userId` _String</td>
    <td>The ID for this user in your database.</td>
  </tr>
  <tr>
    <td>`event` _String_</td>
    <td>The name of the event you're tracking. We recommend human-readable names like `Song Played` or `Status Updated`.</td>
  </tr>
  <tr>
    <td>`properties` _Object, optional_</td>
    <td>A dictionary of properties for the event. If the event was `Product Added`, it might have properties like `price` or `product`.</td>
  </tr>
  <tr>
    <td>`timestamp` _Date, optional_</td>
    <td>A Javascript date object representing when the track took place. If the track just happened, leave it out and we'll use the server's time. If you're importing data from the past make sure you to send a `timestamp`.</td>
  </tr>
  <tr>
    <td>`context` _Object, optional_</td>
    <td>A dictionary of extra [context](https://segment.com/docs/spec/common/#context) to attach to the call. _Note: `context` differs from `traits` because it is not attributes of the user itself._</td>
  </tr>
  <tr>
    <td>`anonymousId` _String, optional_</td>
    <td>An ID to associated with the user when you don't know who they are (eg., [the anonymousId generated by `analytics.js`](/docs/sources/website/analytics.js/#anonymous-id))</td>
  </tr>
</table>

Find details on **best practices in event naming** as well as the **`track` method payload** in our [Spec](/docs/spec/track/).

## Page

The [`page`](/docs/spec/page/) method lets you record page views on your website, along with optional extra information about the page being viewed.

If you're using our client-side setup in combination with the Node.js library, page calls are **already tracked for you** by default. However, if you want to record your own page views manually and aren't using our client-side library, read on!

Example `page` call:

```js
analytics.page({
  userId: '019mr8mf4r',
  category: 'Docs',
  name: 'Node.js Library',
  properties: {
    url: 'https://segment.com/docs/libraries/node',
    path: '/docs/libraries/node/',
    title: 'Node.js Library - Segment',
    referrer: 'https://github.com/segmentio/analytics-node'
  }
});
```

The `page` call has the following fields:

<table>
  <tr>
    <td>`userId` _String</td>
    <td>The ID for this user in your database.</td>
  </tr>
  <tr>
    <td>`category` _String, optional_</td>
    <td>The category of the page. Useful for things like ecommerce where many pages often live under a larger category.</td>
  </tr>
  <tr>
    <td>`name` _String, optional_</td>
    <td>The name of the page, for example **Signup** or **Home**.</td>
  </tr>
  <tr>
    <td>`properties` _Object, optional_</td>
    <td>A dictionary of properties of the page. A few properties specially recognized and automatically translated: `url`, `title`, `referrer` and `path`, but you can add your own too!</td>
  </tr>
  <tr>
    <td>`timestamp` _Date, optional_</td>
    <td>A Javascript date object representing when the track took place. If the track just happened, leave it out and we'll use the server's time. If you're importing data from the past make sure you to send a `timestamp`.</td>
  </tr>
  <tr>
    <td>`context` _Object, optional_</td>
    <td>A dictionary of extra [context](https://segment.com/docs/spec/common/#context) to attach to the call. _Note: `context` differs from `traits` because it is not attributes of the user itself._</td>
  </tr>
  <tr>
    <td>`anonymousId` _String, optional_</td>
    <td>An ID to associated with the user when you don't know who they are (eg., [the anonymousId generated by `analytics.js`](/docs/sources/website/analytics.js/#anonymous-id))</td>
  </tr>
</table>

Find details on the **`page` payload** in our [Spec](/docs/spec/page/).

## Group

`group` lets you associate an [identified user](/docs/sources/server/node/#identify) with a group. A group could be a company, organization, account, project or team! It also lets you record custom traits about the group, like industry or number of employees.

This is useful for tools like [Intercom](/docs/destinations/intercom/), [Preact](/docs/destinations/preact/) and [Totango](/docs/destinations/totango/), as it ties the user to a **group** of other users.

Example `group` call:

```javascript
analytics.group({
  userId: '019mr8mf4r',
  groupId: '56',
  traits: {
    name: 'Initech',
    description: 'Accounting Software'
  }
});
```

The `group` call has the following fields:

<table class="api-table">
  <tr>
    <td>`userId` _string</td>
    <td>The ID for the user that is a part of the group.</td>
  </tr>
  <tr>
    <td>`groupId` _string</td>
    <td>The ID of the group.</td>
  </tr>
  <tr>
    <td>`traits` _dict, optional_</td>
    <td>A dict of traits you know about the group. For a company, they might be things like `name`, `address`, or `phone`.</td>
  </tr>
  <tr>
    <td>`context` _dict, optional_</td>
    <td>A dict containing any context about the request. To see the full reference of supported keys, check them out in the [context reference](/docs/spec/common/#context)</td>
  </tr>
  <tr>
    <td>`timestamp` _datetime, optional_</td>
    <td>A `datetime` object representing when the group took place. If the group just happened, leave it out and we'll use the server's time. If you're importing data from the past make sure you send `timestamp`.</td>
  </tr>
  <tr>
    <td>`anonymousId` _String, optional_</td>
    <td>An ID to associated with the user when you don't know who they are (eg., [the anonymousId generated by `analytics.js`](/docs/sources/website/analytics.js/#anonymous-id))</td>
  </tr>
  <tr>
    <td>`integrations` _dict, optional_</td>
    <td>A dictionary of destinations to enable or disable</td>
  </tr>
</table>

Find more details about `group`, including the **`group` payload**, in our [Spec](/docs/spec/group/).

## Alias

`alias` is how you associate one identity with another. This is an advanced method, but it is required to manage user identities successfully in *some* of our destinations.

In [Mixpanel](/docs/destinations/mixpanel/#alias) it's used to associate an anonymous user with an identified user once they sign up. For [KISSmetrics](/docs/destinations/kissmetrics/#alias), if your user switches IDs, you can use 'alias' to rename the 'userId'.

Example `alias` call:

```javascript
analytics.alias({
  previousId: 'old_id',
  userId: 'new_id'
});
```

The `alias` call has the following fields:

<table class="api-table">
  <tr>
    <td>`userId` _String_</td>
    <td>The ID for this user in your database.</td>
  </tr>
  <tr>
    <td>`previousId` _String_</td>
    <td>The previous ID to alias from.</td>
  </tr>
</table>

Here's a full example of how we might use the `alias` call:

```javascript
// the anonymous user does actions ...
analytics.track({ userId: 'anonymous_user', event: 'Anonymous Event' })
// the anonymous user signs up and is aliased
analytics.alias({ previousId: 'anonymous_user', userId: 'identified@gmail.com' })
// the identified user is identified
analytics.identify({ userId: 'identified@gmail.com', traits: { plan: 'Free' } })
// the identified user does actions ...
analytics.track({ userId: 'identified@gmail.com', event: 'Identified Action' })
```

For more details about `alias`, including the **`alias` call payload**, check out our [Spec](/docs/spec/alias/).

---


## Configuration

The second argument to the `Analytics` constructor is an optional dictionary of settings to configure the module.

```javascript
var analytics = new Analytics('YOUR_WRITE_KEY', {
  flushAt: 20,
  flushInterval: 10000
});
```

<table>
  <tr>
    <td>`flushAt` _Number_</td>
    <td>The number of messages to enqueue before flushing.</td>
  </tr>
  <tr>
    <td>`flushInterval` _Number_</td>
    <td>The number of milliseconds to wait before flushing the queue automatically.</td>
  </tr>
</table>


## Development

You can use this initialization during development to make the library flush every time a message is submitted, so that you can be sure your calls are working properly before pushing to production.

```javascript
var analytics = new Analytics('YOUR_WRITE_KEY', { flushAt: 1 });
```


## Selecting Destinations

The `alias`, `group`, `identify`, `page` and `track` calls can all be passed an object of `integrations` that lets you turn certain destinations on or off. By default all destinations are enabled.

Here's an example with the `integrations` object shown:

```javascript
analytics.track({
  event: 'Membership Upgraded',
  userId: '97234974',
  integrations: {
    'All': false,
    'Vero': true,
    'Google Analytics': false
  }
})
```

In this case, we're specifying that we want this `track` to only go to Vero. `All: false` says that no destination should be enabled unless otherwise specified. `Vero: true` turns on Vero, etc.

Destination flags are **case sensitive** and match [the destination's name in the docs](/docs/destinations) (i.e. "AdLearn Open Platform", "awe.sm", "MailChimp", etc.).

**Note:**

- Available at the business level, filtering track calls can be done right from the Segment UI on your source schema page. We recommend using the UI if possible since it's a much simpler way of managing your filters and can be updated with no code changes on your side.

- If you are on a grandfathered plan, events sent server-side that are filtered through the Segment dashboard will still count towards your API usage.

## Historical Import

You can import historical data by adding the `timestamp` argument to any of your method calls. This can be helpful if you've just switched to Segment.

Historical imports can only be done into destinations that can accept historical timestamped data. Most analytics tools like Mixpanel, Amplitude, Kissmetrics, etc. can handle that type of data just fine. One common destination that does not accept historical data is Google Analytics since their API cannot accept historical data.

**Note:** If you're tracking things that are happening right now, leave out the `timestamp` and our servers will timestamp the requests for you.


## Batching

Our libraries are built to support high performance environments. That means it is safe to use our Node library on a web server that's serving hundreds of requests per second.

Every method you call **does not** result in an HTTP request, but is queued in memory instead. Messages are then flushed in batch in the background, which allows for much faster operation.

By default, our library will flush:

  - The very first time it gets a message.
  - Every 20 messages (controlled by `options.flushAt`).
  - If 10 seconds has passed since the last flush (controlled by `options.flushInterval`)

There is a maximum of `500KB` per batch request and `32KB` per call.

If you don't want to batch messages, you can turn batching off by setting the `flushAt` option to `1`, like so:

```javascript
var analytics = new Analytics('YOUR_WRITE_KEY', { flushAt: 1 });
```

Batching means that your message might not get sent right away. But every method call takes an optional `callback`, which you can use to know when a particular message is flushed from the queue, like so:

```javascript
analytics.track({
  userId: '019mr8mf4r',
  event: 'Ultimate Played'
}, function(err, batch){
  if (err) // There was an error flushing your message...
  // Your message was successfully flushed!
});
```

You can also flush on demand. For example, at the end of your program, you need to flush to make sure that nothing is left in the queue. To do that, call the `flush` method:

```javascript
analytics.flush(function(err, batch){
  console.log('Flushed, and now this program can exit!');
});
```


## Multiple Clients

Different parts of your application may require different types of batching, or even sending to multiple Segment sources. In that case, you can initialize multiple instances of `Analytics` with different settings:

```javascript
var Analytics = require('analytics-node');
var marketingAnalytics = new Analytics('MARKETING_WRITE_KEY');
var appAnalytics = new Analytics('APP_WRITE_KEY');
```


## Troubleshooting

{% include content/troubleshooting-intro.md %}
{% include content/troubleshooting-server-debugger.md %}
{% include content/troubleshooting-server-integration.md %}
