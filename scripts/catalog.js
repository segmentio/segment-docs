const axios = require('axios');
const path = require('path');
const fs = require('fs');
const yaml = require('js-yaml');

require('dotenv').config();

PLATFORM_API_URL = "https://platform.segmentapis.com"

const slugify = (displayName) => {
  let slug = displayName.toLowerCase().replace(/\s+/g, '-')
  if (slug === '.net') slug = 'net'
  if (slug === 'roku-(alpha)') slug = 'roku'
  return slug
}

const getCatalog = async (url, page_token = "") => {
  try {
   const res = await axios.get(url, {
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.PLATFORM_API_TOKEN}`
      },
      params: {
        page_token,
        page_size: 100
      }
    });
    return res.data
  } catch (error) {
    console.log(error)
  }
}

const updateDestinationCategories = async () => {
  let destinations = []
  let nextPageToken = null
  let categories = new Set();
  let destinationCategories = []

  while (nextPageToken !== "") {
    const res = await getCatalog(`${PLATFORM_API_URL}/v1beta/catalog/destinations`, nextPageToken)
    destinations = destinations.concat(res.destinations)
    nextPageToken = res.next_page_token
  }
  destinations.forEach(destination => {
    let temp = [destination.categories.primary, destination.categories.secondary, ...destination.categories.additional]
    temp = temp.filter(category => category != '')
    temp.reduce((s, e) => s.add(e), categories);
  })
  
  const destinationArray = Array.from(categories)
  destinationArray.forEach(category => {
    
    destinationCategories.push({
      display_name: category,
      slug: slugify(category)
    })
  })
  const options = { noArrayIndent: true };
  let output = "# AUTOGENERATED FROM PLATFORM API. DO NOT EDIT\n"
  output += yaml.safeDump({ items: destinationCategories }, options);
  fs.writeFileSync(path.resolve(__dirname, `../src/_data/catalogV2/destination_categories.yml`), output);
}

const updateSourceCategories = async () => {
  let sources = []
  let nextPageToken = null
  let categories = new Set();
  let sourceCategories = []

  while (nextPageToken !== "") {
    const res = await getCatalog(`${PLATFORM_API_URL}/v1beta/catalog/sources`, nextPageToken)
    sources = sources.concat(res.sources)
    nextPageToken = res.next_page_token
  }
  sources.forEach(source => {
    source.categories.reduce((s, e) => s.add(e), categories);
  })
  
  const sourceArray = Array.from(categories)
  sourceArray.forEach(category => {
    
    sourceCategories.push({
      display_name: category,
      slug: slugify(category)
    })
  })
  const options = { noArrayIndent: true };
  let output = "# AUTOGENERATED FROM PLATFORM API. DO NOT EDIT\n"
  output += yaml.safeDump({ items: sourceCategories }, options);
  fs.writeFileSync(path.resolve(__dirname, `../src/_data/catalogV2/source_categories.yml`), output);
}

updateSourceCategories()
updateDestinationCategories()

const updateSources = async () => {
  let sources = []
  let nextPageToken = null
  while (nextPageToken !== "") {
    const res = await getCatalog(`${PLATFORM_API_URL}/v1beta/catalog/sources`, nextPageToken)
    sources = sources.concat(res.sources)
    nextPageToken = res.next_page_token
  }
  sources.sort((a, b) => {
    if(a.display_name < b.display_name) { return -1; }
    if(a.display_name > b.display_name) { return 1; }
    return 0;
  })
  const options = { noArrayIndent: true };
  let output = "# AUTOGENERATED FROM PLATFORM API. DO NOT EDIT\n"
  output += yaml.safeDump({ sections: sources }, options);
  fs.writeFileSync(path.resolve(__dirname, `../src/_data/catalogV2/sources.yml`), output);
}

const updateSourcesV2 = async () => {
  let sources = []
  let sourcesUpdated = []
  let nextPageToken = null

  while (nextPageToken !== "") {
    const res = await getCatalog(`${PLATFORM_API_URL}/v1beta/catalog/sources`, nextPageToken)
    sources = sources.concat(res.sources)
    nextPageToken = res.next_page_token
  }
  sources.sort((a, b) => {
    if(a.display_name < b.display_name) { return -1; }
    if(a.display_name > b.display_name) { return 1; }
    return 0;
  })
  const libraryCategories = [
    'server',
    'mobile',
    'ott',
    'roku',
    'website'
  ]
  sources.forEach(source => {
    let slug = slugify(source.display_name)
   
    let url = ''
    let mainCategory = source.categories[0] ? source.categories[0].toLowerCase() : ''
    if (libraryCategories.includes(mainCategory)) {
      url = `connections/sources/catalog/libraries/${mainCategory}/${slug}`
    } else {
      url = `connections/sources/catalog/cloud-apps/${slug}`
    }
    let updatedSource = {
      display_name: source.display_name,
      slug,
      name: source.name,
      description: source.description,
      url,
      logo: {
        url: source.logos.logo
      },
      mark: {
        url: source.logos.mark
      },
      categories: source.categories
    }
    sourcesUpdated.push(updatedSource)
  })
  const options = { noArrayIndent: true };
  let output = "# AUTOGENERATED FROM PLATFORM API. DO NOT EDIT\n"
  output += yaml.safeDump({ items: sourcesUpdated }, options);
  fs.writeFileSync(path.resolve(__dirname, `../src/_data/catalogV2/sources.yml`), output);
}

const updateDestinations = async () => {
  let destinations = []
  let nextPageToken = null
  while (nextPageToken !== "") {
    const res = await getCatalog(`${PLATFORM_API_URL}/v1beta/catalog/destinations`, nextPageToken)
    destinations = destinations.concat(res.destinations)
    nextPageToken = res.next_page_token
  }
  destinations.sort((a, b) => {
    if(a.display_name < b.display_name) { return -1; }
    if(a.display_name > b.display_name) { return 1; }
    return 0;
  })
  const options = { noArrayIndent: true };
  let output = "# AUTOGENERATED FROM PLATFORM API. DO NOT EDIT\n"
  output += yaml.safeDump({ items: destinations }, options);
  fs.writeFileSync(path.resolve(__dirname, `../src/_data/catalogV2/destinations.yml`), output);
}

const updateDestinationsV2 = async () => {
  let destinations = []
  let destinationsUpdated = []
  let nextPageToken = null
  while (nextPageToken !== "") {
    const res = await getCatalog(`${PLATFORM_API_URL}/v1beta/catalog/destinations`, nextPageToken)
    destinations = destinations.concat(res.destinations)
    nextPageToken = res.next_page_token
  }
  destinations.sort((a, b) => {
    if(a.display_name < b.display_name) { return -1; }
    if(a.display_name > b.display_name) { return 1; }
    return 0;
  })
  destinations.forEach(destination => {
    let slug = slugify(destination.display_name)

    let categories = [destination.categories.primary, destination.categories.secondary, ...destination.categories.additional]
    categories = categories.filter(category => category != '')

    let updatedDestination = {
      display_name: destination.display_name,
      slug,
      name: destination.name,
      description: destination.description,
      url: `connections/destinations/catalog/${slug}`,
      status: destination.status,
      logo:  {
        url: destination.logos.logo
      },
      mark: {
        url: destination.logos.mark
      },
      categories
    }
    destinationsUpdated.push(updatedDestination)
  })
  const options = { noArrayIndent: true };
  let output = "# AUTOGENERATED FROM PLATFORM API. DO NOT EDIT\n"
  output += yaml.safeDump({ items: destinationsUpdated }, options);
  fs.writeFileSync(path.resolve(__dirname, `../src/_data/catalogV2/destinations.yml`), output);
}

// updateSources()
// updateSourcesV2()
// updateDestinations()
// updateDestinationsV2()